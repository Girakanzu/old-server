////
// For license information see the LICENSE document
////

package entice.protocol;

import "entice/protocol/login_service.proto";
import "entice/protocol/world_update.proto";


////
// Hint:
// The container messages are used to encapsulate whole server protocols. We need one for
// each separate server protocol, containing all the possible messages. If the inbound and outbound
// messages differ, then we need different containers for each.
// (E.g.: Login-server and game-servers are using different protocols, plus they probably have inbound
// and outbound specific messages. As a result, we will need different containers for the servers and the
// communication direction)
// However, if we have at least one message that is used in both communication directions, we can a) define
// it in both container messages or b) merge both container messages
// If we wouldnt use the container approach, we would need to define what messages are being send in another
// way (like with special headers and message-length or whatever)
//
// How to use this:
// With this pattern you can wait for only one type of message instead of trying to serialize multiple 
// messagetypes and having to distinguish them somehow. 
////


message ClientToLoginServer {
    optional LoginRequest login_request = 1;
}


message LoginServerToClient {
    optional LoginResponse login_response = 1;
}


message GameServer {
    optional Update update = 1;
}